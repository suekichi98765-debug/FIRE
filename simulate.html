<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIREシミュレーション</title>
    <style>
        /* 4.4. デザイン - ブラウザサイズまで広げ、収まらないときは垂直・水平スライダーで表示 */
        body {
            max-width: none !important;
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f4f7;
            color: #333;
            min-width: 1000px;
            /* 横スクロールを発生させやすくするための最小幅 */
        }

        h1,
        h2 {
            text-align: center;
            color: #2c3e50;
        }

        .simulation-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            /* ボタン間の間隔を調整 */
            justify-content: flex-start;
            /* 左揃え */
            margin-top: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .simulation-button {
            /* 試行回数の数字のみをテキストとするボタンを横に最大25個、左揃えで均等配置。 */
            flex-basis: calc(3%);
            /* 5pxのギャップで25個並べるための計算 */
            height: 30px;
            border-radius: 5px;
            border: 1px solid #ccc;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            line-height: 30px;
            font-size: 12px;
            padding: 0;
        }

        /* 4.2. 成功/失敗ボタン */
        .success {
            background-color: #3498db;
        }

        /* 青色: FIRE成功 */
        .failure {
            background-color: #e74c3c;
        }

        /* 赤色: FIRE失敗 */
        .simulation-button:hover {
            opacity: 0.8;
        }

        .active-chart-button {
            /* グラフが表示されているボタンのスタイル */
            box-shadow: 0 0 5px 3px #f39c12; /* オレンジ色のハイライト */
            border: 2px solid #e67e22;
        }

        /* グラフコンテナにダブルクリックを促すカーソルを追加（任意） */
        #totalAssetChart {
            cursor: pointer;
        }


        /* 4.3. シミュレーション詳細テーブルのデザイン */
        #detail-table-container {
            width: 100%;
            overflow-x: auto;
            /* 水平スクロール */
            margin-top: 30px;
            border: 1px solid #ccc;
            background-color: #fff;
        }

        #detail-table {
            width: 100%;
            font-size: 12px;
            table-layout: fixed;
            /* カラム幅を固定 */
        }

        /* 4.3. テーブル固定表示: テーブルの見出し（2行構成）は、縦スクロールしても常に最上部に表示されるよう固定。 */
        #detail-table thead {
            background-color: #f9f9f9;
            /* 見出しの背景色 */
        }

        #detail-table th,
        #detail-table td {
            border: 1px solid #ddd;
            text-align: center;
            vertical-align: middle;
            white-space: nowrap;
            /* セル内の改行を防ぐ（thは改行タグで制御） */
        }

        #detail-table th {
            background-color: #e9ecef;
            color: #495057;
            text-align: center;
            vertical-align: middle;
        }

        /* 共通項目のカラム幅を固定 */
        #detail-table tr th:nth-child(1) {}

        ,
        #detail-table tr td:nth-child(1) {}

        /* (1) 年月 */
        #detail-table th:nth-child(2),
        #detail-table td:nth-child(2) {}

        /* (2) 引継金融資産額 */
        #detail-table th:nth-child(3),
        #detail-table td:nth-child(3) {}

        /* (3) 出費 */
        #detail-table th:nth-child(4),
        #detail-table td:nth-child(4) {}

        /* (4) 収入 */
        #detail-table th:nth-child(5),
        #detail-table td:nth-child(5) {}

        /* (5) 税金 */
        #detail-table th:nth-child(6),
        #detail-table td:nth-child(6) {}

        /* (6) 保有現金 */
        #detail-table th:nth-child(7),
        #detail-table td:nth-child(7) {}

        /* (7) 追加投資 */
        #detail-table th:nth-child(8),
        #detail-table td:nth-child(8) {}

        /* (8) 期末金融資産額 */
        #detail-table th:nth-child(9),
        #detail-table td:nth-child(9) {}

        /* (9) 総資産 */

        /* 銘柄ごとの詳細カラム幅の固定 (4列: 60 + 100 + 100 + 130 = 390px) */
        /* 銘柄ごとの詳細列は10列目から開始 */
        #detail-table td:nth-child(4n + 10) {}

        /* 利率% */
        #detail-table td:nth-child(4n + 11) {}

        /* 金融資産額 */
        #detail-table td:nth-child(4n + 12) {}

        /* 保有口数の残数 */
        #detail-table td:nth-child(4n + 13) {}

        /* 現在/平均（税金/1口あたり） */

        /* 銘柄ごとの１行目の銘柄毎の集団項目*/
        .meigara-header-group {
            cursor: pointer;
            /* クリック可能であることを示す */
            color: initial;
        }

        .meigara-header-group.collapsed {
            background-color: #fce7e4;
            /* 縮小中であることを視覚的に示す */
            width: 60px !important;
            min-width: 60px !important;
            max-width: 60px !important;
            padding: 0 5px !important;
            /* 銘柄名が視認できる程度のパディングを残す */
            white-space: nowrap;
            /* テキストが折り返されないようにする */
            overflow: hidden;
            text-overflow: ellipsis;
            /* 必要に応じて、銘柄名を省略記号で表示 */
        }

        .collapsed-detail-text {
            /* 最小フォントサイズに設定 (視認不可) */
            font-size: 1px !important;
            /* 文字色を透明にしたい場合は color: transparent も追加できますが、最小サイズで十分です */
            color: transparent !important;
        }


        .kuchisu-increase {
            font-weight: bold;
            /* 口数増加時は太字 */
            color: #27ae60;
        }

        .text-left {
            text-align: left;
        }

        .result-stats {
            margin-top: 20px;
            font-size: 1.1em;
            text-align: center;
        }

        /* 凡例のスタイル */
        #meigara-legend {
            margin-top: 20px;
            padding: 15px;
            background-color: #f0f8ff;
            border: 1px solid #b3d4ff;
            border-radius: 5px;
            text-align: left;
            /* 左寄せ */
        }

        #meigara-legend h3 {
            margin-top: 0;
            font-size: 1.2em;
            color: #3498db;
        }

        /* 5.4. デバッグ機能 */
        #debug-output {
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #e74c3c;
            background-color: #fbe7e4;
            color: #c0392b;
            font-family: monospace;
            white-space: pre-wrap;
            display: none;
            /* 初期は非表示 */
        }
    </style>
</head>

<body>
    <header>
        <h1>FIREシミュレーション結果</h1>
        <a href="index.html" class="nav-button" style="display: block; width: 200px; margin: 0 auto 20px;">メイン画面に戻る</a>
    </header>

    <main>
        <section id="results-summary">

        <div id="dynamic-chart-container" style="display: none; width: 95%; margin: 20px auto; min-height: 350px;">
            <canvas id="totalAssetChart"></canvas>
        </div>

            <h2>シミュレーション結果の概要</h2>
            <div class="result-stats">
                <p id="summary-text">データ読み込み中...</p>
            </div>

            <div class="filter-controls" style="text-align: center; margin-bottom: 20px;">
                <label for="failure-filter">
                    <input type="checkbox" id="failure-filter"> 失敗したケースのみ表示
                </label>
            </div>

            <div id="simulation-buttons" class="simulation-buttons">
            </div>
        </section>

        <section id="simulation-detail" style="display: none;">
            <h2 id="detail-title" style="text-align: left;">シミュレーション詳細（試行 #1）</h2>

            <div id="meigara-legend">
                <h3>凡例</h3>
            </div>

            <div id="detail-table-container">
                <table id="detail-table">
                    <thead>
                        <tr id="header-row-1">
                            <th class="text-left" id="header-row-1-month" rowspan="2">(1)<br>年月</th>
                        </tr>
                        <tr id="header-row-2">
                            <th>(2) 引継<br>金融資産額</th>
                            <th>(3) 出費</th>
                            <th>(4) 収入</th>
                            <th>(5) 税金</th>
                            <th>(6) 保有現金</th>
                            <th>(7) 追加投資</th>
                            <th>(8) 期末<br>金融資産額</th>
                            <th>(9) 総資産</th>
                        </tr>
                    </thead>
                    <tbody id="detail-table-body">
                    </tbody>
                </table>
            </div>
        </section>

        <div id="debug-output">
            <h3>デバッグ出力</h3>
            <pre id="debug-content"></pre>
        </div>

    </main>

    <script src="app.js"></script>
    <script src="chart.min.js"></script>

    <script>
        // --- numeric.js (最小限の機能のみを想定して、ここではダミー関数を定義します。実際のコードに差し替えてください。) ---
        const numeric = {
            rep: (row, col, value = 0) => {
                const matrix = [];
                for (let i = 0; i < row; i++) {
                    matrix.push(new Array(col).fill(value));
                }
                return matrix;
            },
            dot: (A, B) => {
                if (A[0].length !== B.length) {
                    console.error("行列の次元が一致しません");
                    return numeric.rep(A.length, B[0].length, 0);
                }
                const result = numeric.rep(A.length, B[0].length);
                for (let i = 0; i < A.length; i++) {
                    for (let j = 0; j < B[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < A[0].length; k++) {
                            sum += A[i][k] * B[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            },
            identity: (n) => {
                const matrix = numeric.rep(n, n);
                for (let i = 0; i < n; i++) {
                    matrix[i][i] = 1;
                }
                return matrix;
            },
            cholesky: (R) => {
                const n = R.length;
                const L = numeric.rep(n, n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j <= i; j++) {
                        if (i === j) {
                            let sum = 0;
                            for (let k = 0; k < j; k++) {
                                sum += L[j][k] * L[j][k];
                            }
                            const diagVal = R[i][i] - sum;
                            if (diagVal < 0) {
                                throw new Error(`コレスキー分解エラー: 負の対角要素 (${diagVal.toFixed(4)})`);
                            }
                            L[i][j] = Math.sqrt(diagVal);
                        } else {
                            let sum = 0;
                            for (let k = 0; k < j; k++) {
                                sum += L[i][k] * L[j][k];
                            }
                            if (L[j][j] === 0) {
                                L[i][j] = 0;
                            } else {
                                L[i][j] = (R[i][j] - sum) / L[j][j];
                            }
                        }
                    }
                }
                return L;
            },
            transpose: (M) => {
                const rows = M.length;
                const cols = M[0].length;
                const result = numeric.rep(cols, rows);
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[j][i] = M[i][j];
                    }
                }
                return result;
            },
            random: {
                normal: (mu = 0, sigma = 1) => {
                    let u = 0, v = 0;
                    while (u === 0) u = Math.random();
                    while (v === 0) v = Math.random();
                    let mag = sigma * Math.sqrt(-2.0 * Math.log(u));
                    return mag * Math.cos(2.0 * Math.PI * v) + mu;
                }
            }
        };
        // --- numeric.js 終了 ---


        // --- モンテカルロ・シミュレーションのプログラムを関数に分割 ---

        const debugOutput = (message) => {
            const debugDiv = document.getElementById('debug-output');
            const debugContent = document.getElementById('debug-content');
            if (debugDiv && debugContent) {
                // debugDiv.style.display = 'block'; // デバッグ表示を有効にする場合はコメント解除
                debugContent.textContent += message + '\n';
            }
        };

        /**
         * 月次税率を決定する
         */
        function calculateTaxRate(monthIndex, taxEvents) {
            let rate = 0.20315; // デフォルト 20.315%
            const taxRateEvent = taxEvents.slice().reverse().find(t => monthIndex >= t.month);
            if (taxRateEvent) {
                rate = taxRateEvent.rate / 100;
            }
            return rate;
        }


        /**
         * 収入と出費を処理し、現金残高を更新し、不足額を返す
         * @param {number} monthIndex - 現在の経過月数
         * @param {number} currentCash - 現在の保有現金
         * @param {object} appData - アプリケーションデータ
         * @param {number} currentMonthlyLifeCost - インフレ適用済みの現在の月次生活費
         */
        function handleIncomeAndExpense(monthIndex, currentCash, appData, currentMonthlyLifeCost) {
            const { bigExpense, income } = appData;

            // 1. 収入処理 
            const incomeEvent = income.find(inc =>
                monthIndex >= inc.startTotalMonths &&
                (inc.endTotalMonths === null || inc.endTotalMonths === undefined || monthIndex <= inc.endTotalMonths)
            );
            const monthlyIncome = incomeEvent ? incomeEvent.amount : 0;
            currentCash += monthlyIncome;

            // 2. 出費処理
            const baseLifeCost = currentMonthlyLifeCost;

            // 大口出費を検索
            const bigExpenseEvent = bigExpense.find(be => be.month === monthIndex);
            const bigExpenseAmount = bigExpenseEvent ? bigExpenseEvent.amount : 0;

            // 月次総出費 (表示用/計算用)
            const monthlyTotalExpense = baseLifeCost + bigExpenseAmount;

            let requiredAssetSale = 0; // 不足額（資産売却が必要な額）
            let cashBalance = currentCash;

            if (cashBalance >= monthlyTotalExpense) {
                cashBalance -= monthlyTotalExpense;
            } else {
                requiredAssetSale = monthlyTotalExpense - cashBalance; // 不足額
                cashBalance = 0;
            }

            return {
                currentCash: cashBalance,
                monthlyIncome: monthlyIncome,
                totalExpense: monthlyTotalExpense, // (3) 出費表示用は、シンプルに月次総出費を返す
                requiredAssetSale: requiredAssetSale // 不足額
            };
        }



        /**
         * 追加投資を処理し、保有口数と平均取得価額を更新する
         */
        function handleTuikaInvestment(monthIndex, currentCash, currentStocks, appData, meigaraNames) {
            const tuikaEvents = appData.tuika.filter(tui => tui.month === monthIndex);
            let monthlyTuikaInvestment = 0;

            for (const tuika of tuikaEvents) {
                const targetStockIndex = meigaraNames.indexOf(tuika.meigara);
                if (targetStockIndex === -1) continue;

                const targetStock = currentStocks[targetStockIndex];
                const investmentAmount = tuika.amount;

                if (currentCash < investmentAmount) {
                    debugOutput(`追加投資失敗(${tuika.meigara}): 現金不足。`);
                    continue;
                }

                currentCash -= investmentAmount;
                monthlyTuikaInvestment += investmentAmount;

                const pricePerUnit = targetStock.CurrentValuePerUnit / targetStock.Tani;
                if (pricePerUnit <= 0) continue;

                const boughtKuchisu = Math.floor(investmentAmount / pricePerUnit);

                const oldTotalValue = targetStock.Kuchisu * (targetStock.AveragePrice / targetStock.Tani);
                const newTotalValue = oldTotalValue + investmentAmount;
                const newTotalKuchisu = targetStock.Kuchisu + boughtKuchisu;

                targetStock.Kuchisu = newTotalKuchisu;

                if (newTotalKuchisu > 0) {
                    const newAveragePricePerUnit = newTotalValue / newTotalKuchisu;
                    targetStock.AveragePrice = newAveragePricePerUnit * targetStock.Tani;
                }
                debugOutput(`追加投資成功(${tuika.meigara}): 投資額${investmentAmount}, 購入口数${boughtKuchisu}`);
            }

            return { currentCash, monthlyTuikaInvestment };
        }

        /**
         * 現金不足を補うために金融資産を売却する
         */
        function handleAssetSale(requiredExpense, currentCash, currentStocks, trialCurrentTaxRate, monthIndex) {
            let sellProceeds = 0;
            let taxPayment = 0;
            let fireFailure = false;

            let totalFinancialAssets = currentStocks.reduce((sum, s) => {
                const valuePerUnit = s.CurrentValuePerUnit / s.Tani;
                return sum + (s.Kuchisu * valuePerUnit);
            }, 0);

            if (totalFinancialAssets < requiredExpense) {
                fireFailure = true;
                return { currentCash, taxPayment, sellProceeds, fireFailure };
            }

            let netSaleAmountNeeded = requiredExpense;
            let requiredSaleProceeds = netSaleAmountNeeded; // 売却総額（税引き前）の目標

            const MAX_SELL_TRIALS = 5; // 税金調整のための試行回数制限

            // 1. 税金を見越した目標売却総額の決定
            for (let sellTrial = 0; sellTrial < MAX_SELL_TRIALS; sellTrial++) {
                let totalGrossSaleAmount = 0;
                let calculatedTax = 0;

                const totalCurrentAssets = currentStocks.reduce((sum, s) => sum + (s.Kuchisu * (s.CurrentValuePerUnit / s.Tani)), 0);
                if (totalCurrentAssets <= 0) break;

                const targetSaleRatio = totalCurrentAssets > 0 ? requiredSaleProceeds / totalCurrentAssets : 0;

                for (const stock of currentStocks) {
                    const { CurrentValuePerUnit, AveragePrice, Tani, Kuchisu, TaxStartYear, TaxStartMonth } = stock;

                    const taxStartMonthIndex = TaxStartYear * 12 + (TaxStartMonth === 0 ? 0 : TaxStartMonth - 1);
                    const isTaxable = (TaxStartYear === null || TaxStartMonth === null) ? false :
                        ((TaxStartYear === 0 && (TaxStartMonth === 0 || TaxStartMonth === 1)) || monthIndex >= taxStartMonthIndex);
                    const hasProfit = CurrentValuePerUnit > AveragePrice;

                    const currentStockValue = Kuchisu * (CurrentValuePerUnit / Tani);
                    let targetSaleValue = currentStockValue * targetSaleRatio;
                    let actualKuchisuToSell = Math.ceil(targetSaleValue / (CurrentValuePerUnit / Tani));
                    actualKuchisuToSell = Math.min(Kuchisu, Math.max(0, actualKuchisuToSell));

                    const saleProceedsBeforeTax = actualKuchisuToSell * (CurrentValuePerUnit / Tani);
                    totalGrossSaleAmount += saleProceedsBeforeTax;

                    if (isTaxable && hasProfit && actualKuchisuToSell > 0) {
                        const profit = actualKuchisuToSell * ((CurrentValuePerUnit - AveragePrice) / Tani);
                        calculatedTax += profit * trialCurrentTaxRate;
                    }
                }

                taxPayment = calculatedTax; // 試行で計算された税額
                const netSaleProceeds = totalGrossSaleAmount - taxPayment;

                if (netSaleProceeds >= netSaleAmountNeeded) {
                    requiredSaleProceeds = totalGrossSaleAmount; // 必要な売却総額が確定
                    break;
                } else {
                    requiredSaleProceeds = (netSaleAmountNeeded + taxPayment); // 目標売却総額を増やして再試行
                    if (totalCurrentAssets < requiredSaleProceeds) {
                        requiredSaleProceeds = totalCurrentAssets;
                        break;
                    }
                }
            }

            // 2. 最終売却処理
            const finalTotalAssets = currentStocks.reduce((sum, s) => sum + (s.Kuchisu * (s.CurrentValuePerUnit / s.Tani)), 0);
            const finalTargetSaleRatio = finalTotalAssets > 0 ? requiredSaleProceeds / finalTotalAssets : 0;
            sellProceeds = 0;

            for (const stock of currentStocks) {
                const { CurrentValuePerUnit, Tani, Kuchisu } = stock;
                if (Kuchisu === 0) continue;

                const currentStockValue = Kuchisu * (CurrentValuePerUnit / Tani);
                let targetSaleValue = currentStockValue * finalTargetSaleRatio;
                let actualKuchisuToSell = Math.ceil(targetSaleValue / (CurrentValuePerUnit / Tani));
                actualKuchisuToSell = Math.min(Kuchisu, Math.max(0, actualKuchisuToSell));

                const saleProceedsBeforeTax = actualKuchisuToSell * (CurrentValuePerUnit / Tani);
                sellProceeds += saleProceedsBeforeTax;
                stock.Kuchisu -= actualKuchisuToSell;
            }

            const netSaleProceeds = sellProceeds - taxPayment;

            if (netSaleProceeds >= requiredExpense) {
                const surplusCash = netSaleProceeds - requiredExpense;
                currentCash += Math.floor(surplusCash); // 余剰金を現金に追加
            } else {
                fireFailure = true;
            }

            return { currentCash, taxPayment, sellProceeds, fireFailure };
        }

        /**
         * 銘柄の利率変動を適用し、月末の資産額と詳細を計算する
         */
        function applyMonthlyReturn(monthIndex, currentStocks, L, trialCurrentTaxRate) {
            const numStocks = currentStocks.length;
            const standardNormals = Array(numStocks).fill(0).map(() => numeric.random.normal());
            const Y = numeric.dot(L, standardNormals.map(n => [n]));
            const stockDetails = [];
            let endOfPeriodAssets = 0;

            for (let i = 0; i < numStocks; i++) {
                const stock = currentStocks[i];

                if (stock.Kuchisu <= 0) {
                    stockDetails.push({ rate: 0, value: 0, kuchisu: 0, currentValuePerUnit: 0, averagePrice: stock.AveragePrice, taxPerUnit: 0 });
                    continue;
                }

                // 利率変動計算
                const monthlyVolatility = stock.Volatility / 100 / Math.sqrt(12);
                const monthlyReturn = stock.Return / 100 / 12;
                const correlatedZ = Y[i][0];

                //その月のその銘柄に適用する、利率を計算する
                const monthlyRate = Math.exp(
                    (monthlyReturn - monthlyVolatility * monthlyVolatility / 2) +
                    (monthlyVolatility * correlatedZ)
                ) - 1;

                // 単位口数当たりの新しい価額に更新
                stock.CurrentValuePerUnit *= (1 + monthlyRate);

                // 新しい金融資産額
                const currentValuePerUnit = stock.CurrentValuePerUnit;
                const pricePerUnit = currentValuePerUnit / stock.Tani;
                const financialAssetValue = stock.Kuchisu * pricePerUnit;
                endOfPeriodAssets += financialAssetValue;

                // 表示用税額の計算
                let taxPerUnit = 0;
                const taxStartMonthIndex = stock.TaxStartYear * 12 + (stock.TaxStartMonth === 0 ? 0 : stock.TaxStartMonth - 1);
                const isTaxable = (stock.TaxStartYear === null || stock.TaxStartMonth === null) ? false :
                    ((stock.TaxStartYear === 0 && (stock.TaxStartMonth === 0 || stock.TaxStartMonth === 1)) || monthIndex >= taxStartMonthIndex);

                if (isTaxable && currentValuePerUnit > stock.AveragePrice) {
                    const profitPerUnit = (currentValuePerUnit - stock.AveragePrice) / stock.Tani;
                    taxPerUnit = profitPerUnit * trialCurrentTaxRate;
                }

                stockDetails.push({
                    rate: monthlyRate * 100, // %表示
                    value: financialAssetValue,
                    kuchisu: stock.Kuchisu,
                    currentValuePerUnit: currentValuePerUnit,
                    averagePrice: stock.AveragePrice,
                    taxPerUnit: taxPerUnit
                });
            }

            return { stockDetails, endOfPeriodAssets };
        }

        /**
         * モンテカルロ・シミュレーションを実行するメイン関数
         */
        function runMonteCarloSimulation(appData) {
            debugOutput('--- シミュレーション開始 ---');
            const config = appData.config;
            const stocks = appData.stocks;
            const totalPeriods = config.period * 12;
            const numTrials = config.times;
            const numStocks = stocks.length;
            const meigaraNames = stocks.map(s => s.Meigara);

            if (numStocks === 0) return [];


            // データの準備: 相関行列Rとコレスキー分解L
            const R = numeric.identity(numStocks);
            appData.soukan.forEach(item => {
                const indexA = meigaraNames.indexOf(item.A_Meigara);
                const indexB = meigaraNames.indexOf(item.B_Meigara);
                if (indexA !== -1 && indexB !== -1) {
                    R[indexA][indexB] = item.keisu;
                    R[indexB][indexA] = item.keisu;
                }
            });

            let L;
            try {
                L = numeric.cholesky(R);
            } catch (error) {
                debugOutput('エラー: コレスキー分解に失敗しました。' + error.message);
                return [];
            }
            debugOutput('コレスキー分解完了。');

            const inflationRate = config.inflationRate / 100; // configから取得した%を小数に変換
            // LifeCostイベントを月数順にソート
            const lifeCostEvents = appData.lifeCost.sort((a, b) => a.month - b.month);
            let lifeCostEventIndex = -1;

            // 1. 初期生活費の特定 (month=0または最も早く発生するイベント)
            let currentMonthlyLifeCost = 0;
            if (lifeCostEvents.length > 0) {
                const initialLifeCostEvent = lifeCostEvents.find(lc => lc.month === 0);

                if (initialLifeCostEvent) {
                    // 0ヶ月目のイベントがあればそれを初期値とする
                    currentMonthlyLifeCost = initialLifeCostEvent.amount;
                    lifeCostEventIndex = lifeCostEvents.indexOf(initialLifeCostEvent);
                } else {
                    // 0ヶ月のイベントがない場合は、設定がないとみなし 0 円とする
                    currentMonthlyLifeCost = 0;
                }
            } else {
                // lifeCostの設定自体がない場合は0円
                currentMonthlyLifeCost = 0;
            }

            // lifeCostEventIndexが-1の場合、0番目の要素を指すように調整する
            if (lifeCostEventIndex === -1 && lifeCostEvents.length > 0) {
                // たとえ月が0でなくても、最初のイベントを起点としておく
                lifeCostEventIndex = 0;
                currentMonthlyLifeCost = lifeCostEvents[0].amount;
            }

            const simulationResults = [];

            // 全試行回数をループ
            for (let t = 0; t < numTrials; t++) {

                let lifeCostEventIndex = -1;
                let currentMonthlyLifeCost = 0;

                if (lifeCostEvents.length > 0) {
                    const initialLifeCostEvent = lifeCostEvents.find(lc => lc.month === 0);
                    if (initialLifeCostEvent) {
                        currentMonthlyLifeCost = initialLifeCostEvent.amount;
                        lifeCostEventIndex = lifeCostEvents.indexOf(initialLifeCostEvent);
                    } else {
                        currentMonthlyLifeCost = 0;
                    }
                } else {
                    currentMonthlyLifeCost = 0;
                }

                if (lifeCostEventIndex === -1 && lifeCostEvents.length > 0) {
                    lifeCostEventIndex = 0;
                    currentMonthlyLifeCost = lifeCostEvents[0].amount;
                }


                let currentCash = config.cash; // (6) 保有現金 (初期値)
                // 銘柄の初期状態をディープコピー
                const currentStocks = stocks.map(s => ({
                    ...s,
                    Kuchisu: s.Kuchisu,
                    CurrentValuePerUnit: s.CurrentValuePerUnit,
                    AveragePrice: s.AveragePrice,
                }));
                let fireFailure = false;
                let failureMonth = -1; // 失敗が確定した月数 (0ベース) を記録
                const history = [];

                // シミュレーション期間を月ごとにループ
                for (let monthIndex = 0; monthIndex < totalPeriods; monthIndex++) {

                    if (fireFailure) break;
                    const yearMonthStr = `${Math.floor(monthIndex / 12)}年${(monthIndex % 12) + 1}月`;

                    const transferAssets = monthIndex === 0 ?
                        stocks.reduce((sum, s) => sum + (s.Kuchisu / s.Tani * s.CurrentValuePerUnit), 0) :
                        history[monthIndex - 1].endOfPeriodAssets;

                    // 1. 月次税率の決定
                    const trialCurrentTaxRate = calculateTaxRate(monthIndex, appData.tax);

                    // 1. 月次インフレとライフコストイベントのチェック
                    let lifeCostReset = false;

                    // LifeCostイベントの切り替わりチェック (次のイベントがこの月に発生するか)
                    if (lifeCostEventIndex + 1 < lifeCostEvents.length) {
                        const nextEvent = lifeCostEvents[lifeCostEventIndex + 1];
                        if (monthIndex === nextEvent.month) {
                            // A期間からB期間への切替: B期間の予定出費（nextEvent.amount）を基準にリセット
                            // インフレ結果に関わらず、B期間の基準値で再スタートする
                            currentMonthlyLifeCost = nextEvent.amount;
                            lifeCostEventIndex++;
                            lifeCostReset = true;
                        }
                    }
                    // 毎年1月（monthIndexが12で割り切れる、かつ0ヶ月目ではない）にインフレを適用
                    // monthIndex 12, 24, 36, ... が 1月（経過1年後、2年後...の1月）
                    if (monthIndex > 0 && monthIndex % 12 === 0 && !lifeCostReset) {
                        currentMonthlyLifeCost *= (1 + inflationRate);
                    }
                    const monthlyLifeCostForSimulation = currentMonthlyLifeCost;


                    // 2. 収入と出費の処理 (追加投資・売却前の現金残高と不足額を計算)
                    const { currentCash: cashAfterIncomeExpense, monthlyIncome, totalExpense, requiredAssetSale } = handleIncomeAndExpense(
                        monthIndex,
                        currentCash,
                        appData,
                        monthlyLifeCostForSimulation // インフレ適用済み出費を渡す
                    );
                    currentCash = cashAfterIncomeExpense;
                    let requiredExpense = requiredAssetSale;

                    // 3. 追加投資処理
                    const tuikaResult = handleTuikaInvestment(monthIndex, currentCash, currentStocks, appData, meigaraNames);
                    currentCash = tuikaResult.currentCash;

                    // 4. 金融資産の売却 (現金不足の場合)
                    let taxPayment = 0;
                    if (requiredExpense > 0) {
                        const saleResult = handleAssetSale(requiredExpense, currentCash, currentStocks, trialCurrentTaxRate, monthIndex);
                        currentCash = saleResult.currentCash;
                        taxPayment = saleResult.taxPayment;
                        fireFailure = saleResult.fireFailure;
                        if (fireFailure) {
                            failureMonth = monthIndex; //ここで失敗月数を記録
                            debugOutput(`資産枯渇によりFIRE失敗 (${yearMonthStr})`);
                        }
                    }

                    // 5. 利率変動
                    const returnResult = applyMonthlyReturn(monthIndex, currentStocks, L, trialCurrentTaxRate);
                    const endOfPeriodAssets = returnResult.endOfPeriodAssets;
                    const stockDetails = returnResult.stockDetails;

                    // 6. 資産枯渇の確認 (総資産)
                    const totalAsset = endOfPeriodAssets + currentCash;
                    if (totalAsset < 0) {
                        fireFailure = true;
                        failureMonth = monthIndex; //ここで失敗月数を記録
                    }

                    // 月次履歴を記録
                    history.push({
                        yearMonth: yearMonthStr,
                        transferAssets: transferAssets, // (2) 引継金融資産額
                        expense: totalExpense, // (3) 出費 ← expenseResult.totalExpense を totalExpense に変更
                        income: monthlyIncome, // (4) 収入 ← expenseResult.monthlyIncome を monthlyIncome に変更
                        tax: taxPayment, // (5) 税金
                        cash: currentCash, // (6) 保有現金 (月末残高)
                        tuika: tuikaResult.monthlyTuikaInvestment, // (7) 追加投資
                        endOfPeriodAssets: endOfPeriodAssets, // (8) 期末金融資産額
                        totalAsset: totalAsset, // (9) 総資産
                        stockDetails: stockDetails,
                        isFailure: fireFailure
                    });
                }

                simulationResults.push({
                    trialId: t + 1,
                    success: !fireFailure,
                    failureMonth: fireFailure ? failureMonth : totalPeriods,
                    history: history
                });
                debugOutput(`試行 #${t + 1} 完了。成功: ${!fireFailure}`);

            }

            debugOutput('--- シミュレーション完了 ---');
            return simulationResults;
        }

        // --- モンテカルロ・シミュレーションのプログラム終了 ---

        //チャート生成用
        let totalAssetChartInstance = null;
	let currentActiveButton = null;

        // ... (DOM操作と表示制御のコードは変更なし) ...
        document.addEventListener('DOMContentLoaded', () => {
            const simulationButtonsDiv = document.getElementById('simulation-buttons');
            const summaryText = document.getElementById('summary-text');
            const detailSection = document.getElementById('simulation-detail');
            const detailTitle = document.getElementById('detail-title');
            const detailTableBody = document.getElementById('detail-table-body');
            const failureFilter = document.getElementById('failure-filter');
            const meigaraLegend = document.getElementById('meigara-legend');
            const headerRow1 = document.getElementById('header-row-1');
            const headerRow2 = document.getElementById('header-row-2');

		//グラフの領域
	    const dynamicChartContainer = document.getElementById('dynamic-chart-container');
	    const totalAssetChart = document.getElementById('totalAssetChart');


            let simulationResults = [];
            let currentTrialIndex = -1;
            let meigaraNames = [];

            /**
             * 銘柄ごとのヘッダーセルを動的に生成する
             * @param {Array} stocks - 銘柄情報の配列
             */
            function setupTableHeader(stocks) {
                let child = headerRow1.lastElementChild;
                while (child && child.id !== 'header-row-1-month') {
                    if (headerRow1.children.length > 1) {
                        headerRow1.removeChild(headerRow1.lastElementChild);
                    } else {
                        break;
                    }
                    child = headerRow1.lastElementChild;
                }

                while (headerRow2.children.length > 9) {
                    headerRow2.removeChild(headerRow2.lastChild);
                }

                meigaraNames = stocks.map(s => s.Meigara);

                // 銘柄の数だけヘッダーを追加
                stocks.forEach((stock, index) => {
                    // 1行目: 銘柄名
                    const th1 = document.createElement('th');
                    th1.colSpan = "4";
                    th1.textContent = `銘柄${String.fromCharCode(65 + index)}`

                    //銘柄ヘッダをクリックすると、イベントが発動するようにする。	追加開始
                    th1.classList.add('meigara-header-group');
                    th1.dataset.meigaraIndex = index; // 0, 1, 2, ... のインデックス
                    //銘柄ヘッダをクリックすると、イベントが発動するようにする。	追加終了

                    headerRow1.appendChild(th1);

                    // 2行目: 詳細項目 (4つのセル)
                    const th2_rate = document.createElement('th');
                    th2_rate.textContent = '利率％';
                    headerRow2.appendChild(th2_rate);

                    const th2_value = document.createElement('th');
                    th2_value.textContent = '資産額';
                    headerRow2.appendChild(th2_value);

                    const th2_kuchisu = document.createElement('th');
                    th2_kuchisu.textContent = '保有口数';
                    headerRow2.appendChild(th2_kuchisu);

                    const th2_price = document.createElement('th');
                    th2_price.innerHTML = '現在/<br>平均<br>(税額/1口)';
                    headerRow2.appendChild(th2_price);
                });

                // 1行目の共通項目のヘッダー（月次収支・資産総額）を動的に追加
                const th1_common = document.createElement('th');
                th1_common.colSpan = "8";
                th1_common.textContent = '月次収支・資産総額';
                headerRow1.insertBefore(th1_common, headerRow1.children[1]);

                // 凡例の設定
                const legendHtml = '<h3>凡例</h3>';
                meigaraLegend.innerHTML = legendHtml + stocks.map((s, i) =>
                    `銘柄${String.fromCharCode(65 + i)}: ${s.Meigara}`
                ).join('<br>') + '<BR><BR>※　テーブルの銘柄A、銘柄B・・・をクリックすると、幅を縮めたり広げたりできます。<br>';
            }


            /**
             * シミュレーション詳細テーブルに結果を表示
             * @param {number} trialIndex - 表示する試行のインデックス
             * @param {HTMLElement} clickedButton - クリックされたボタン要素 ← ★★★ この行を追加 ★★★
             */
            function displaySimulationDetail(trialIndex, clickedButton) {
                currentTrialIndex = trialIndex;
                const result = simulationResults[trialIndex];
                const history = result.history;

                detailTitle.textContent = `シミュレーション詳細（試行 #${result.trialId} - ${result.success ? '成功' : '失敗'}）`;
                detailTableBody.innerHTML = ''; // テーブルをクリア

                history.forEach((entry, historyIndex) => {
                    const row = detailTableBody.insertRow();

                    // (1) 年月
                    let rowHtml = `<td class="text-left">${entry.yearMonth}</td>`;

                    // (2) 引継金融資産額 
                    let transferAssets = entry.transferAssets;
                    rowHtml += `<td>${window.formatNumber(transferAssets)}</td>`;

                    // (3) 出費 - 手取りとして必要な金額 
                    rowHtml += `<td>${window.formatNumber(entry.expense)}</td>`;
                    // (4) 収入
                    rowHtml += `<td>${window.formatNumber(entry.income)}</td>`;
                    // (5) 税金
                    rowHtml += `<td>${window.formatNumber(entry.tax)}</td>`;
                    // (6) 保有現金
                    rowHtml += `<td>${window.formatNumber(entry.cash)}</td>`;
                    // (7) 追加投資
                    rowHtml += `<td>${window.formatNumber(entry.tuika)}</td>`;

                    // (8) 期末金融資産額 - ( )をつけた対前月比の差を記載

                    const investmentChange = entry.endOfPeriodAssets - (entry.transferAssets + entry.tuika);

                    const assetChangeText = `${window.formatNumber(entry.endOfPeriodAssets)}<br>(${window.formatNumber(investmentChange)})`;
                    rowHtml += `<td>${assetChangeText}</td>`;

                    // (9) 総資産
                    rowHtml += `<td>${window.formatNumber(entry.totalAsset)}</td>`;

                    // 銘柄ごとの資産額の表示
                    entry.stockDetails.forEach((stock, stockIndex) => {
                        const initialStockData = window.appData.stocks[stockIndex];

                        // *保有口数の残数（セル）*
                        const prevStockKuchisu = historyIndex === 0 ? initialStockData.Kuchisu : history[historyIndex - 1].stockDetails[stockIndex].kuchisu;
                        const kuchisuChange = stock.kuchisu - prevStockKuchisu;
                        const kuchisuChangeText = kuchisuChange > 0 ? `<span class="kuchisu-increase">(+${window.formatNumber(kuchisuChange)})</span>` : `(${window.formatNumber(kuchisuChange)})`;
                        const kuchisuCell = `${window.formatNumber(stock.kuchisu)}<br>${kuchisuChangeText}`;

                        // *現在価額/平均取得価額（セル）*
                        const currentValuePerUnit = stock.currentValuePerUnit;
                        const averagePrice = stock.averagePrice;
                        const priceLine = `${window.formatNumber(currentValuePerUnit)}/${window.formatNumber(averagePrice)}`;

                        const taxPerUnitText = stock.taxPerUnit > 0.0000001 ? `(${stock.taxPerUnit.toFixed(4)}円/口)` : `無税`;

                        const priceCell = `${priceLine}<br>${taxPerUnitText}`;

                        // セルを追加
                        rowHtml += `
                            <td>${stock.rate.toFixed(2)}%</td>
                            <td>${window.formatNumber(stock.value)}</td>
                            <td>${kuchisuCell}</td>
                            <td>${priceCell}</td>
                        `;
                    });

                    row.innerHTML = rowHtml;
                    detailTableBody.appendChild(row);
                });

                detailSection.style.display = 'block';


		// --- グラフ表示位置の動的変更 ---
		// クリックされたボタンの直後にグラフコンテナを移動
		clickedButton.after(dynamicChartContainer);
		dynamicChartContainer.style.display = 'block';	 // グラフを表示

                //グラフ描画ロジックの追加
                const labels = history.map(entry => entry.yearMonth);
                const data = history.map(entry => entry.totalAsset);

                 const ctx = totalAssetChart.getContext('2d'); // totalAssetChart を使用

                // 既存のグラフがあれば破棄して新しい描画に備える
                if (totalAssetChartInstance) {
                    totalAssetChartInstance.destroy();
                }

                // 新しい折れ線グラフを作成
                totalAssetChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            // 1. 総資産の推移 (リニア軸 - 左)
                            {
                                label: '(9) 総資産の推移 (リニア)',
                                data: data,
                                borderColor: result.success ? '#3498db' : '#e74c3c', // 成功:青, 失敗:赤
                                backgroundColor: result.success ? 'rgba(52, 152, 219, 0.1)' : 'rgba(231, 76, 60, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1,
                                fill: true,
                                yAxisID: 'y' // 左側のリニア軸を使用
                            },
                            // 2. 総資産の推移 (対数軸 - 右)
                            {
                                label: '(9) 総資産の推移 (対数)',
                                data: data,
                                borderColor: '#2ecc71', // 緑色に変更
                                backgroundColor: 'transparent', // 塗りつぶしなし
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1,
                                fill: false, // 塗りつぶしなし
                                yAxisID: 'y1', // 新しい対数軸を使用
                                borderDash: [5, 5] // 破線にするなどして区別しやすくする
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `試行 #${result.trialId} の総資産の推移 (${result.success ? '成功' : '失敗'})`
                            },
                            legend: {
                                display: true, // 凡例を表示して2つのグラフを区別
                                position: 'top',
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '期間'
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 20
                                }
                            },
                            // 左側のY軸 (リニア)
                            y: {
                                type: 'linear', // 明示的にリニアを設定
                                position: 'left', // 左側に配置
                                title: {
                                    display: true,
                                    text: '総資産額 (リニアスケール)'
                                },
                                beginAtZero: false,
                                ticks: {
                                    // 軸の目盛りを分かりやすくフォーマット
                                    callback: function (value) {
                                        return window.formatNumber(value);
                                    }
                                }
                            },
                            // 右側のY軸 (対数)
                            y1: {
                                type: 'logarithmic', // 対数スケールを設定
                                position: 'right', // 右側に配置
                                title: {
                                    display: true,
                                    text: '総資産額 (対数スケール)'
                                },
                                grid: {
                                    drawOnChartArea: false, // グラフ領域に線を引かない
                                },
                                ticks: {
                                    callback: function (value) {
                                        // 対数軸は目盛りの値を整形するのに特別な処理が必要な場合がある
                                        if (value >= 10000000000) return window.formatNumber(value / 10000000000) + '兆';
                                        if (value >= 100000000) return window.formatNumber(value / 100000000) + '億';
                                        if (value >= 10000) return window.formatNumber(value / 10000) + '万';
                                        return window.formatNumber(value);
                                    }
                                }
                            }
                        }
                    }
                });

		// --- グラフのダブルクリックイベントの設定 ---
		totalAssetChart.ondblclick = () => {
			hideChart(); // 新しい非表示関数を呼び出す
		};
		currentActiveButton = clickedButton; // 最後にアクティブになったボタンを記憶

            }

	/**
	 * グラフを非表示にする関数
	 */
	function hideChart() {
		if (totalAssetChartInstance) {
			totalAssetChartInstance.destroy();
			totalAssetChartInstance = null;
		}
		dynamicChartContainer.style.display = 'none'; // グラフコンテナを非表示
		// 最後にクリックされたボタンのハイライトを解除したい場合はここで処理
		if (currentActiveButton) {
			currentActiveButton.classList.remove('active-chart-button');
			currentActiveButton = null;
		}
	}

            /**
             * シミュレーションボタンの表示を更新
             * @param {boolean} showFailuresOnly - 失敗ケースのみを表示するかどうか
             */
            function updateSimulationButtons(showFailuresOnly) {
                simulationButtonsDiv.innerHTML = '';

                simulationResults.forEach((result, index) => {
                    if (showFailuresOnly && result.success) return;

                    const button = document.createElement('button');
                    button.id = `result-${result.trialId}`;
                    button.className = `simulation-button ${result.success ? 'success' : 'failure'}`;
                    button.textContent = result.trialId;

                    button.addEventListener('click', () => {
				// 同じボタンがクリックされたら非表示にする
				if (currentActiveButton === event.currentTarget) {
					hideChart();
					return;
				}
				// 既にアクティブなボタンがあれば、そのハイライトを解除
				if (currentActiveButton) {
					currentActiveButton.classList.remove('active-chart-button');
				}
				// 新しくクリックされたボタンをアクティブにし、詳細を表示
				event.currentTarget.classList.add('active-chart-button');
				displaySimulationDetail(index, event.currentTarget); // クリックされたボタンを渡す
			});

                    simulationButtonsDiv.appendChild(button);
                });

                // 成功/失敗のサマリーを更新
                const successCount = simulationResults.filter(r => r.success).length;
                const failureCount = simulationResults.length - successCount;
                const successRate = (simulationResults.length > 0 ? successCount / simulationResults.length * 100 : 0).toFixed(1);

                // 1. 成功ケースの統計 (最終総資産)
                const successfulFinalAssets = simulationResults
                    .filter(r => r.success)
                    .map(r => r.history[r.history.length - 1].totalAsset);

                let medianAsset = 0;
                let worst10thAsset = 0;

                if (successfulFinalAssets.length > 0) {
                    medianAsset = calculatePercentile(successfulFinalAssets, 50);
                    worst10thAsset = calculatePercentile(successfulFinalAssets, 10);
                }

                // 2. 失敗ケースの統計 (最終総資産と失敗月数)
                const failureFinalAssets = simulationResults
                    .filter(r => !r.success)
                    .map(r => r.history[r.history.length - 1].totalAsset);

                const failureMonths = simulationResults
                    .filter(r => !r.success)
                    .map(r => r.failureMonth + 1); // 0ベースの月数に+1して表示月数に

                let medianFailureAsset = 0;
                let medianFailureMonth = 0;

                if (failureFinalAssets.length > 0) {
                    medianFailureAsset = calculatePercentile(failureFinalAssets, 50);

                    // 失敗確定期間の中央値（月数）を計算
                    medianFailureMonth = calculatePercentile(failureMonths, 50);
                }

                // 3. 全体評価の生成
                const overallAssessment = generateOverallAssessment(parseFloat(successRate), worst10thAsset);

                // 4. サマリーテキストの更新 (HTML構造の変更)
                // 月数を「X年 Yヶ月」形式に変換するヘルパー関数
                const formatMonths = (months) => {
                    const totalMonths = Math.round(months);
                    if (totalMonths <= 0) return "開始時";
                    const years = Math.floor(totalMonths / 12);
                    const m = totalMonths % 12;
                    if (years > 0) {
                        return `${years}年${m}ヶ月`;
                    }
                    return `${m}ヶ月`;
                };

                summaryText.innerHTML = `
			    <h2>全体評価</h2>
			    <p style="font-size: 1.2em; font-weight: bold; color: #2980b9;">
			        ${overallAssessment}
			    </p>
			    <hr style="margin: 15px 0;">

			    **試行回数:** ${simulationResults.length}回<br>
			    **FIRE成功率:** <span style="color:#3498db; font-size: 1.1em; font-weight: bold;">${successRate}%</span> (${successCount}回)<br>
			    **FIRE失敗率:** <span style="color:#e74c3c; font-size: 1.1em; font-weight: bold;">${(100 - successRate).toFixed(1)}%</span> (${failureCount}回)
			    <hr style="margin: 10px 0;">

			    <div style="display: flex; justify-content: space-around; text-align: left; padding: 10px;">
			        <div style="padding-right: 15px; flex: 1;">
		            <h3>✅ 成功ケース (最終総資産予測)</h3>
		            <p>
		                <span style="font-weight: bold;">中央値 (50%タイル):</span> ${window.formatNumber(Math.round(medianAsset))} 円<br>
		                <span style="font-weight: bold; color: #e67e22;">悲観的なケース (10%タイル):</span> ${window.formatNumber(Math.round(worst10thAsset))} 円
		            </p>
		            <span style="font-size: 0.9em; display: block;">※ 90%の確率で、10%タイル以上の資産が残ります。</span>
			        </div>
        
			        <div style="border-left: 1px solid #ccc; padding-left: 15px; flex: 1;">
			            <h3>❌ 失敗ケース (リスク分析)</h3>
			            <p>
			                <span style="font-weight: bold;">失敗までの期間 (中央値):</span> ${formatMonths(medianFailureMonth)}<br>
			                <span style="font-weight: bold; color: #c0392b;">終了時資産 (中央値):</span> ${window.formatNumber(Math.round(medianFailureAsset))} 円
			            </p>
			            <span style="font-size: 0.9em; display: block;">※ 失敗リスクが発生した場合、この期間で資産が枯渇する可能性が高いです。</span>
			        </div>
			    </div>
			`;

                // 詳細表示の表示/非表示を制御するロジック
                if (currentTrialIndex !== -1) {
                    const currentResult = simulationResults[currentTrialIndex];

                    // 詳細が表示されている試行が、現在のフィルター（失敗のみ）で非表示になるべきかチェック
                    if (currentResult && showFailuresOnly && currentResult.success) {
                        detailSection.style.display = 'none';
                    } else {
                        detailSection.style.display = 'block';
                    }
                }
            }



            /**
                 * 配列から指定されたパーセンタイル値を計算する
                 * @param {Array<number>} data - 数値の配列
                 * @param {number} percentile - 求めるパーセンタイル (0-100)
                 * @returns {number} パーセンタイル値
                 */
            function calculatePercentile(data, percentile) {
                if (data.length === 0) return 0;
                const sortedData = [...data].sort((a, b) => a - b);
                const index = (percentile / 100) * (sortedData.length - 1);
                if (index % 1 === 0) {
                    return sortedData[index];
                } else {
                    const lower = Math.floor(index);
                    const upper = Math.ceil(index);
                    const weight = index - lower;
                    return sortedData[lower] * (1 - weight) + sortedData[upper] * weight;
                }
            }

            /**
                 * 成功率と悲観的なケースの資産額に基づき、総合的な評価文を生成する
                 */
            function generateOverallAssessment(successRate, worst10thAsset) {
                let assessment = "";

                if (successRate >= 99) {
                    stars = '★★★★★★★★★★';
                    comment = `【評価：FIREしちゃいますか！】成功率 ${successRate.toFixed(1)} で、もうFIREせずに後悔する人生のほうがリスクかもしれません。資産が枯渇したら運がなかったと諦められるレベルです。`;
                } else if (successRate >= 95) {
                    stars = '★★★★★';
                    comment = `【評価：極めて高い確実性】成功率 ${successRate.toFixed(1)} で、あなたのFIRE計画は極めて高い確実性を持っています。資産が枯渇する確率は非常に低いですが、**さらなる特異な出費や、一時的な自国通貨安、または複数の危機が重なる「パーフェクトストーム」のような事態が連続すれば、最悪のシナリオでは枯渇する可能性も残ります。**この計画は優秀ですが、正社員を辞めるという行為は取り返しがつかないため、常に市場を注視する姿勢は崩すべきではありません。`;
                } else if (successRate >= 90) {
                    stars = '★★★★☆';
                    comment = `【評価：高い確実性だがリスクあり】成功率 ${successRate.toFixed(1)} は、一般的な基準では高い確実性です。しかし、FIREは取り返しのつかない決断であり、${(100 - successRate).toFixed(1)}%の確率で資産が尽きる未来が示されています。**予期せぬ大きな出費や、市場が長期間停滞する「パーフェクトストーム」のような事態が重なった場合、資産は枯渇します。**このリスクを真剣に受け止め、万が一の場合の収入源を確保するなど、より厳しい検討が必要です。`;
                } else if (successRate >= 80) {
                    stars = '★★★☆☆';
                    comment = `【評価：危険水域・十分な検討が必要】成功率 ${successRate.toFixed(1)} は、FIREの確実性としては不十分です。成功と失敗が約20%の差で発生しており、資産が枯渇する可能性は無視できません。**特異な出費や、一時的な自国通貨安、またはインフレの予想以上の進行が重なる最悪のケースでは、計画は容易に破綻します。**計画を実行に移す前に、資産の増強や生活費の見直しを強く推奨します。`;
                } else if (successRate >= 50) {
                    stars = '★★☆☆☆';
                    comment = `【評価：極めて危険】成功率 ${successRate.toFixed(1)} は、**失敗する確率が成功する確率とほとんど変わりません。**この状態でFIREに踏み切るのは極めて危険です。少しでも想定外の事態が発生すれば、資産の枯渇は時間の問題となります。**計画の見直しは必須であり、現状のデータでは正社員を辞めるべきではありません。**`;
                } else {
                    stars = '★☆☆☆☆';
                    comment = `【評価：FIRE不可能】成功率 ${successRate.toFixed(1)} で、シミュレーションの大半で資産が枯渇するという結果になりました。**この計画ではFIREは不可能と考えられます。**直ちに出費の削減、収入源の確保、または投資リターンの再検討（リスク許容度とのバランスを見極める）を行ってください。`;
                }

		assessment = stars + "<BR>" + comment;
                if (successRate >= 50 && worst10thAsset <= 0) {
                    assessment += "<br>→ **【注意】** 成功ケースであっても、運が悪いと資産がほとんど残らない（またはマイナスになる）可能性があります。";
                }

                return assessment;
            }


            // --- メイン処理 ---

            const storedData = localStorage.getItem('fireSimulatorData');
            if (!storedData) {
                summaryText.textContent = 'エラー: 設定データがLocalStorageに見つかりません。設定ページでデータを保存してください。';
                return;
            }

            try {
                //各種設定ページの設定情報の読み込み
                const appData = JSON.parse(storedData);
                window.appData = appData;

                if (!appData.stocks || appData.stocks.length === 0) {
                    summaryText.textContent = 'エラー: 保有銘柄が登録されていません。シミュレーションを実行できません。';
                    return;
                }

                // 1. ヘッダーの初期設定と凡例の準備
                setupTableHeader(appData.stocks);

                // 2. シミュレーションの実行 (simulate.htmlを開いた直後に開始)
                simulationResults = runMonteCarloSimulation(appData);

                // 3. 結果の表示
                updateSimulationButtons(false);

                // 4. 絞り込み機能のイベントリスナー
                failureFilter.addEventListener('change', (event) => {
                    updateSimulationButtons(event.target.checked);
                });

            } catch (e) {
                summaryText.textContent = `データの読み込みまたはシミュレーション実行中にエラーが発生しました: ${e.message}`;
                debugOutput(`致命的なエラー: ${e.stack}`);
                document.getElementById('debug-output').style.display = 'block';
            }
        });

        //シミュレーション詳細のテーブルの各銘柄の資産状況の推移情報の表示・非表示処理
        document.addEventListener('DOMContentLoaded', () => {
            const table = document.getElementById('detail-table');
            if (!table) {
                return;
            }
            const meigaraHeaders = table.querySelectorAll('.meigara-header-group');
            meigaraHeaders.forEach(header => {
                header.addEventListener('click', (event) => {
                    //1行目の銘柄項目に横幅の標準化・最小化の処理を行う
                    // ★★★ 銘柄ヘッダーセル自体に縮小クラスをトグルするだけに変更 ★★★
                    event.currentTarget.classList.toggle('collapsed');
                    //クリックされた銘柄の番号を取得
                    const meigaraIndex = parseInt(event.currentTarget.dataset.meigaraIndex, 10);

                    //２行目以降のフォントサイズを１にして見えないようにする
                    const isCollapsed = event.currentTarget.classList.contains('collapsed');
                    // 銘柄の開始列インデックスを計算 (1-based index)
                    const startColumnIndex_1based = 10 + (meigaraIndex * 4);
                    //銘柄の詳細項目数を取得
                    const COLUMNS_PER_STOCK = parseInt(event.currentTarget.getAttribute('colspan'), 10);
                    // テーブルのすべての行 (ヘッダー行とデータ行) を取得
                    const allRows = document.querySelectorAll('#detail-table tr');
                    allRows.forEach(row => {
                        // 4つの列をまとめて操作
                        for (let i = 0; i < COLUMNS_PER_STOCK; i++) {
                            // 行が 'header-row-2' の場合、共通項目数は8（rowspan=2の影響で1つ少ない）
                            let columnIndex_1based = startColumnIndex_1based + i;
                            if (row.id === 'header-row-2') {	//２行目だけ特殊なので、対象列を１つずらす
                                columnIndex_1based--;
                            }
                            // CSSの :nth-child(n) セレクタを使ってセルを取得
                            const cell = row.querySelector(`:nth-child(${columnIndex_1based})`);
                            if (cell) {
                                if (isCollapsed) {
                                    // 縮小時: テキストを透明に
                                    cell.classList.add('collapsed-detail-text');
                                } else {
                                    // 展開時: テキスト色を黒色（デフォルト）に戻す
                                    cell.classList.remove('collapsed-detail-text');
                                }
                            }
                        }
                    });

                });
            });
        });
    </script>
</body>

</html>